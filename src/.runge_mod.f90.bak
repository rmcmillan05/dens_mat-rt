MODULE runge_mod
    USE double
    IMPLICIT NONE
    PRIVATE
    PUBLIC :: runge

CONTAINS

SUBROUTINE runge(rho_out,t_out,rho_0, ham, gma, mu, nptspau, L, field, positions,ps)
    USE double
    USE fields
    USE params, ONLY : time_par 
    IMPLICIT NONE
    LOGICAL, INTENT(IN) :: ps ! (print positions to screen)
    COMPLEX(KIND=DP), ALLOCATABLE, DIMENSION(:,:,:), INTENT(OUT) :: rho_out
    REAL(KIND=DP) , ALLOCATABLE, DIMENSION(:), INTENT(OUT) :: t_out
    COMPLEX(KIND=DP), ALLOCATABLE, DIMENSION(:,:) :: rho
    COMPLEX(KIND=DP), ALLOCATABLE, DIMENSION(:,:)              :: k1, k2, k3, k4
    COMPLEX(KIND=DP), INTENT(IN), DIMENSION(:,:)               :: rho_0, ham, gma, mu
    INTEGER, INTENT(IN)                                        :: nptspau ! npts per a.u.
    INTEGER :: npts ! total npts
    REAL(KIND=DP), INTENT(IN)                                  :: L
    CHARACTER(LEN=*), INTENT(IN)                               :: field
    INTEGER, INTENT(IN), DIMENSION(:,:)                        :: positions
    INTEGER                                                    :: s, i, j
    INTEGER                                                    :: r
    REAL(KIND=DP)                                              :: h, t
    COMPLEX(KIND=DP), PARAMETER                        :: ci=(0.0_DP,1.0_DP)
    CHARACTER(LEN=2)        :: poschar
    CHARACTER(LEN=16)       :: fieldchar

    r = UBOUND(positions, 1)
    s = UBOUND(rho_0, 1)

    h = 1.0_DP/REAL(nptspau,KIND=DP)
    npts = nptspau * NINT(L)

    ALLOCATE(rho(s,s), k1(s,s), k2(s,s), k3(s,s), k4(s,s))
        

    IF (ps .EQV. .FALSE.) THEN
        ALLOCATE(rho_out(s,s,npts+1), t_out(npts+1))
    ENDIF

    rho = rho_0
    t   = 0.0_DP

    IF (ps .EQV. .TRUE.) THEN
        !! PRINTING TITLES FOR COLUMNS !!
        WRITE(*, '(A16)', ADVANCE='NO') ' t              '
        fieldchar=' '//TRIM(field)//'(t)'
        WRITE(*, '(A16)', ADVANCE='NO') fieldchar
        DO j = 1, r
            WRITE(*, '(A5)', ADVANCE='NO') ' rho_'
            WRITE(poschar, '(I2)') positions(j,1)
            WRITE(*, '(A3)', ADVANCE='NO') poschar//','
            WRITE(poschar, '(I2)') positions(j,2)
            WRITE(*, '(A2)', ADVANCE='NO') poschar
            WRITE(*, '(A22)', ADVANCE='NO') ''
        ENDDO
        WRITE(*,*)

        !! PRINTING VALUES AT t=0 !!
        WRITE(*, '(F16.9)', ADVANCE='NO') t
        WRITE(*, '(F16.9)', ADVANCE='NO') efield(field, t)
        DO j = 1, r
            WRITE(*, '(2F16.9)', ADVANCE='NO') &
            rho(positions(j,1),positions(j,2))
        ENDDO                                 
        WRITE(*,*)
    ELSE
        t_out(1) = t
        rho_out(:,:,1) = rho
    ENDIF

    DO i = 0, npts-1

        k1 = h * ( - ci*commute(ham,rho)                 &
                   + ci*efield(field,t)*commute(mu,rho)  &
                   - gma*rho )

        k2 = h * ( - ci*commute(ham,rho+0.5_DP*k1)                         &
                   + ci*efield(field,t+0.5_DP*h)*commute(mu,rho+0.5_DP*k1) &
                   - gma*(rho+0.5_DP*k1) )

        k3 = h * ( - ci*commute(ham,rho+0.5_DP*k2)                         &
                   + ci*efield(field,t+0.5_DP*h)*commute(mu,rho+0.5_DP*k2) &
                   - gma*(rho+0.5_DP*k2) )

        k4 = h * ( - ci*commute(ham,rho+k3)                  &
                   + ci*efield(field,t+h)*commute(mu,rho+k3) &
                   - gma*(rho+k3) )

        rho = rho + (k1 + (2.0_DP *k2) + (2.0_DP *k3) + k4) / 6.0_DP
        t   = t + h


        IF (ps .EQV. .TRUE.) THEN
            !! PRINTING VALUES !!
            WRITE(*, '(F16.9)', ADVANCE='NO') t*time_par
            WRITE(*, '(F16.9)', ADVANCE='NO') efield(field, t)
            DO j = 1, r
                WRITE(*, '(2F16.9)', ADVANCE='NO') &
                rho(positions(j,1),positions(j,2))
            ENDDO                                 
            WRITE(*,*)
        ELSE
            t_out(i+2) = t
            rho_out(:,:,i+2) = rho
        ENDIF
    ENDDO

END SUBROUTINE runge

FUNCTION commute(A, B)
    USE double
    USE omp_lib
    IMPLICIT NONE
    COMPLEX(KIND=DP), INTENT(IN), DIMENSION(:,:) :: A, B
    COMPLEX(KIND=DP), ALLOCATABLE                :: commute(:,:)
    COMPLEX(KIND=DP) :: y
    INTEGER                                   :: s, nu, n, m

    s = UBOUND(A,1)
    ALLOCATE(commute(s,s))

!$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(n,m,nu,y) SCHEDULE(DYNAMIC)
    DO n = 1,s
        DO m = 1,s
            y = (0.0_DP, 0.0_DP)
            DO nu = 1,s
                y = y + A(n, nu)*B(nu, m) - B(n, nu)*A(nu, m)
            ENDDO
            commute(n,m) = y
        ENDDO
    ENDDO
!$OMP  END PARALLEL DO

END FUNCTION commute

END MODULE runge_mod
